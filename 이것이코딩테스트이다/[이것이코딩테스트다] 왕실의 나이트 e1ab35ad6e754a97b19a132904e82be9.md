# [이것이코딩테스트다] 왕실의 나이트

# 문제

- 나이트는 말을 타고 있기 때문에 이동을 할 때 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 나이트는 특정한 위치에서 다음과 같은 2가지 경우로 이동할 수 있다.
    1. 수평으로 두 칸 이동한 뒤에 수직으로 한칸 이동하기
    2. 수직으로 두 칸 이동한 뒤 수평으로 한칸 이동하기

![%5B%E1%84%8B%E1%85%B5%E1%84%80%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%83%E1%85%A1%5D%20%E1%84%8B%E1%85%AA%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%82%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B3%20e1ab35ad6e754a97b19a132904e82be9/Screen_Shot_2021-06-01_at_4.00.52_PM.png](%5B%E1%84%8B%E1%85%B5%E1%84%80%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%83%E1%85%A1%5D%20%E1%84%8B%E1%85%AA%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%82%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B3%20e1ab35ad6e754a97b19a132904e82be9/Screen_Shot_2021-06-01_at_4.00.52_PM.png)

- 8*8 좌표 평면상에서 나이트위 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하라. 이때 왕실의 정원에서 행 위치를 표현할 때는 1~8, 열 위치를 표현할 때는 'a' ~ 'h'로 표현한다.

이 문제를 풀기 전에 무한한 평면에서 한 점에 있는 나이트가 움직일 수 있는 경우의 수를 생각해보면 처음엔 16가지(경로가 다른 경우 포함하여)라고 생각하였다. 하지만 조건에서는 수평으로  두칸 이동하면 수직은 한칸만 이동하고, 수직으로 두칸 이동하면, 수평은 한칸만 이동하는 방식으로 중복을 제거하였다. 

```python
pos = input()
col, row = pos[0], pos[1]
cnt = 0
col_table = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
row_table = ['1', '2', '3', '4', '5', '6', '7', '8']
check_list = [-2, -1, 1, 2]

# print(row_table.index(row))

for i in check_list:
    if int(row_table.index(row)) + i < 0 or int(row_table.index(row)) + i > 7:
        continue
    for j in check_list:
        if i == j or i == -j:
            continue
        if int(col_table.index(col)) + j < 0 or int(col_table.index(col)) + j > 7:
            continue
        cnt += 1

print(cnt)
```

처음 문제를 풀 때 움직일 수 있는 경우의 수를 이중 for문을 사용해 만약 움직일 수 있는 경우를 (-2, -2), (1, -1)을 제외하는 것으로 구현을 해보았다. 하지만 뒤의 풀이를 보았을 때 for문을 하나만 사용하여 구현하는 방법을 배웠다.

```python
pos = input()
row = int(pos[1])
col = int(ord(pos[0])) - ord('a') + 1
cnt = 0
steps = [(-2, -1), (-1, -2), (-2, 1), (-1, 2),
         (2, -1), (1, -2), (2, 1), (1, 2)]

for i in steps:
    if row - int(i[1]) < 1 or row - int(i[1]) > 8 or col - int(i[0]) < 1 or col - int(i[0]) > 8:
        continue
    cnt += 1

print(cnt)
```

우선, 나이트의 좌표를 (문자)와 (숫자)로 이루어진 형식으로 받을 때 문자를 '유니코드'형식으로 해서 숫자로 변환 후 좌표를 좀 더 쉽게 사용할 수 있도록 했다.

그 다음 나이트가 움직일 수 있는 경우의 수는 8가지이므로, 완전 탐색 방식을 사용했다. 그 다음 이동하고 난 위치가 좌표 평면을 벗어나는 경우를 예외로 두어서 pass하게끔 설정한다.

이렇게 설계한다면, 불필요한 for문이 필요하지 않고, 속도를 늘릴 수 있다고 생각한다.