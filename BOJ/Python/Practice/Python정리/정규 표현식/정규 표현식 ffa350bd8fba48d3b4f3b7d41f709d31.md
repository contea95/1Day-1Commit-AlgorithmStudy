# 정규 표현식

# 1. 정규 표현식 살펴보기

'정규 표현식'은 복잡한 문자열을 처리할 때 사용하는 기법. 문자열을 처리하는 모든 곳에서 사용. 

## 정규 표현식 필요 이유

주민등록번호를 포함하고 있는 텍스트가 있다. 이 텍스트에 포함된 모든 주민등록번호의 뒷자리를 * 문자로 변경.

정규식을 모르면 다음과 같은 순서로 프로그램 작성

1. 전체 텍스트를 공백 문자로 나눈다(split)
2. 나뉜 단어가 주민등록번호 형식인지 조사한다.
3. 단어가 주민등록번호 형식이면 뒷자리를 *로 변환
4. 나뉜 단어를 다시 조립한다.

```python
data = '''
park    800905-1049118
kim     700905-1059119
'''

result = []
for line in data.split("\n"):
    word_result = []
    for word in line.split(" "):
        if(len(word) == 14 and word[:6].isdigit() and word[7:].isdigit()):
            word = word[:6] + "-" + "*******"
        word_result.append(word)
    result.append(" ".join(word_result))
print("\n".join(result))
```

정규표현식으로 사용하면 간단하게 사용할 수 있다.

```python
import re

data = '''
park    800905-1049118
kim     700905-1059119
'''

pat = re.compile("(\d{6})[-]\d{7}")
print(pat.sub("\g<1>-********", data))
```

# 2. 정규 표현식 시작하기

## 정규 표현식의 기초, 메타 문자

정규 표현식에서 사용하는 메타 문자는 다음과 같은 것이 있다.

.  ^  $  *  +  ?  {  }  [  ]  \  |  (  )

### 문자 클래스 [ ]

문자 클래스로 만들어진 정규식은 "[  ]  사이의 문자들과 매치" 라는 의미

즉, 정규 표현식이 [abc]라면 이 표현식은 "a,b,c 중 한 개의 문자와 매치" 라는 뜻이다.

"a", "before", "dude" 가 정규식 [abc]와 어떻게 매치되는지 보자.

- "a"는 정규식과 일치하는 문자인 "a" 가 있으므로 매치
- "before"도 마찬가지로 매치
- "dude"는 일치하는 문자가 없으므로 매치되지 않음.

[ ] 안의 두 문자 사이에 하이픈을 사용하면 두 문자 사이의 범위 [From - To]를 의미한다.

- [a-zA-Z] : 알파벳 모두
- [0-9] : 숫자

주의해야할 메타 문자는 ^ 이다. 이는 반대라는 의미를 갖는데, [^0-9] 라는 정규식은 숫자가 아닌 문자만 매치된다.

### [자주 사용하는 문자 클래스]

[0-9], [a-zA-Z]는 자주 사용하는 정규 표현식이다.

- \d - 숫자와 매치, [0-9]와 동일하다.
- \D - 숫자가 아닌 것과 매치, [^0-9]와 동일.
- \s = whitespace 문자와 매치, [ \t\n\r\f\v]와 동일한 표현식이다.
- \S = whitespace 문자가 아닌 것과 매치, [^ \t\n\r\f\v]와 동일.
- \w = 문자 + 숫자와 매치, [a-zA-Z0-9_]와 동일.
- \W = 문자 + 숫자가 아닌 것과 매치, [^a-zA-Z0-9_]와 동일한 표현식.

## Dot(.)

정규 표현식인 . 메타 문자는 줄바꿈 문자인 \n 을 제외한 모든 문자와 매치됨을 의미한다.

단, re.DOTALL 옵션을 주면 \n 문자와 매치된다.

a.b

위 정규식 의미는 "a + 모든 문자 + b" 를 의미한다. 즉 a와 b 문자 사이에 어떤 문자가 들어가도 된다는 의미이다.

- "aab"는 .과 일치, 정규식과 매치
- "a0b"는 0이 .과 일치, 정규식과 매치
- "abc"는 a,b 문자 사이에 아무 것도 없으므로 매치되지 않는다.

a[.]b

위 정규식 의미는 "a + [.]문자 + b" 와 같다. 

따라서 정규식 a[.]b는 "a.b" 문자열과 매치되고, "a0b" 문자열과는 매치되지 않는다.

## 반복 (*)

ca*t

여기서 반복을 의미하는 * 메타 문자가 사용. * 바로 앞에 있는 문자 a가 0~무한대로 반복될 수 있다는 의미.

즉, ct, cat, caaaat 가 전부 다 매치될 수 있다.

## 반복 (+)

+메타 문자는 최소 1번 이상 반복될 때 사용. * 과의 차이는 1번부터 매치된다는 것.

ca+t

ct는 매치되지 않고, cat, caaat만 매치될 수 있다.

## 반복 ({m,n}, ?)

반복 횟수를 제한할 때 사용한다. {m,n} 정규식을 사용하여 반복 횟수가 m부터 n까지 매치할 수 있다. 또한 m 또는 n 을 생략할 수 있다. {3,} 처럼 사용하면 반복 횟수가 3 이상인 경우이고 {,3}을 사용하면 반복 횟수가 3이하를 의미한다. m은 0과 동일.

{}을 사용한 몇 가지 정규식을 살펴보자.

1. {m}

ca{2}t

위 정규식은 "c + a(반드시 2번 반복) + t"와 같다. 즉 caat만 매치된다.

2. {m,n}

ca{2,5}t

위 정규식은 "c + a(2~5번 반복) + t"

3. ?

반복은 아니지만 ?가 의미하는 것은 {0,1} 이다.

ab?c

위 정규식은 "a + b(있어도 되고 없어도 된다.) + c"

## 파이썬에서 정규 표현식을 지원하는 re모듈

파이썬에서는 정규 표현식 re(regular expression)모듈을 제공.

```python
import re
p = re.compile('ab*')
```

re.complie을 사용하여 정규 표현식을 컴파일한다. re.compile의 결과로 돌려주는 객체 p를 이용하여 이후 작업을 수행한다.

## 정규식을 이용한 문자열 검색

컴파일 된 패턴 객체를 사용해 문자열 검색을 수행.

- match() : 정규식과 매치되는지 조사
- search() : 문자열 전체를 검색하여 정규식과 매치되는지 조사
- findall() : 정규식과 매치되는 모든 문자열(substrig)을 리스트로 리턴
- finditer() : 정규식과 매치되는 모든 문자열을 반복 가능한 객체로 리턴

match, search는 정규식과 매치될 때는 match 객체를 돌려주고, 매치되지 않을 때는 None을 돌려준다.

```python
>>> import re
>>> p = re.compile('[a-z]+')
```

다음과 같은 패턴을 만들자.

### match

match 메서드는 문자열을 처음부터 정규식과 매치되는지 조사

```python
>>> m = p.match("python")
>>> print(m)
<_sre.SRE_Match object at 0x01F3F9F8>
```

"python" 문자열은 [a-z]+ 정규식에 부합되므로 match 객체를 돌려준다.

```python
>>> m = p.match("3 python")
>>> print(m)
None
```

"3 pyhton" 문자열은 처음에 나오는 문자 3이 정규식에 부합되지 않아 None을 돌려준다.

```python
p = re.compile(정규표현식)
m = p.match('string goes here')
if m:
    print('Match found: ' m.group())
else:
    print('No match')
```

match 결과값이 있을 때만 그 다음 작업을 수행하겠다는 것.

### search

컴파일된 패턴 객체  p를 가지고 search 메서드 수행

```python
>>> m = p.search("python")
>>> print(m)
<_sre.SRE_Match object at 0x01F3FA68>
```

"python" 문자열에 search 메서드를 수행하면 match 메서드를 수행했을 때와 동일하게 매치.

```python
>>> m = p.search("3 python")
>>> print(m)
<_sre.SRE_Match object at 0x01F3FA30>
```

"3 python" 문자열의 첫 문자 3과는 매치되는 것이 아닌 3 이후의 python 문자열과 매치.

### findall

```python
>>> result = p.findall("life is too short")
>>> print(result)
['life','is','too','short']
```

각 단어를 [a-z]+ 정규식과 매치해서 리스트로 돌려준다.

### finditer

```python
>>> result = p.finditer("life is too short")
>>> print(result)
<callable_iterator object at 0x01F5E390>
>>> for r in result: print(r)
...
<_sre.SRE_Match object at 0x01F3F9F8>
<_sre.SRE_Match object at 0x01F3FAD8>
<_sre.SRE_Match object at 0x01F3FAA0>
<_sre.SRE_Match object at 0x01F3F9F8>
```

finditer은 결과로 반복가능한 객체를 리턴한다. 반복 가능한 객체가 포함하는 각 요소는 match 객체이다.