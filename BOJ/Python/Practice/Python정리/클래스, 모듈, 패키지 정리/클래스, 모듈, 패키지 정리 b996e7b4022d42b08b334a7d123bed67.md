# 클래스, 모듈, 패키지 정리

# 1. 클래스

## 클래스 필요 이유

계산기를 생각해보자. 숫자 3을 입력하고 +기호 입력 후 입력한 4를 입력하면 결과값인 7을 출력, 다시 +를 입력후 3을 입력하면 기존 결과값 7에 3을 더한 10을 보여준다. 이는 이전에 계산한 결과값을 항상 메모리 어딘가에 저장하고 있어야 한다.

```python
result = 0

def add(num):
    global result
    result += num
    return result

print(add(3))
print(add(4))
```

이전에 계산한 결과값으 유지하기 위해 result 전역 변수(global)를 사용한다. 프로그램을 실행하면 예상한 대로 3, 7과 같은 결과값이 출력된다.

그런데 만일 한 프로그램에서 2대의 계산기가 필요하면 어떻게 될까? 각 계산기는 각각의 결과값을 유지해야 하기 때문에 위와 같이 add 함수 하나만으로는 결과값을 따로 유지할 수 없다.

이 문제를 해결하려면 add1, add2와 같은 함수를 따로 추가해야 한다. 하지만 이렇게 한다면 계산기가 3개, 4개 등으로 늘어나면 어떻게 해야할까?

이는 클래프를 사용하면 해결할 수 있다.

```python
class Calculator:
    def __init__(self):
		    self.result = 0

    def add(self, num):
        self.result += num
        return self.result

cal1 = Calculator()
cal2 = Calculator()

print(cal1.add(3))
```

Calculator 클래스로 만든 별개의 계산기 cal1, cal2 (객체)가 각각의 역할을 한다. 그리고 계산기(cal1, cal2)의 결과값 역시 다른 계산기의 결과값과 상관없이 독립적인 값을 유지한다. 클래스를 사용하면 계산기 대수가 늘어나더라도 객체를 생성하기만 하면 되기 때문에 함수를 사용하는 경우와 달리 매우 간단해진다. 빼기 기능도 클래스에 추가해주면 된다.

```python
def sub(self, num):
    self.result -=num
    return self.result
```

## 클래스와 객체

클래스를 과자와 틀에 비교해보자

- 과자 틀 → 클래스
- 과자 틀에 의해 만들어진 과자 → 객체

클래스로 만든 객체는 각 객체마다 고유한 성격을 가진다.

### 객체와 인스턴스 차이

클래스로 만든 객체를 인스턴스라고 한다. 객체와 인스턴스의 차이를 알아보자.

a = Cookie()로 만든 a는 객체이다. 그리고 객체 a는 Cookie의 인스턴스이다. 즉 인스턴스는 특정 개체(a)가 어떤 클래스의 객체인지 설명할 때 사용한다. 'a는 인스턴스' 보다는 'a는 객체'라는 표현이 어울리며 'a는 Cookie의 객체' 보다는 'a는 Cookie의 인스턴스'라는 표현으로 얘기해야한다.

## 사칙연산 클래스 만드는 과정

### 클래스 구상하기

클래스 객체 중심으로 어떤 식으로 동작하게 할 것인지 구상 후 하나씩 해결하면서 완성해 나가는 것이 좋다.

```python
a = FourCal() # 사칙 연산을 하는 FourCal클래스
a.setdata(4,2) # 데이터 세트
a.add()
a.mul()
a.sub()
a.div()
```

위 기능을 수행하는 클래스 제작

### 클래스 구조 만들기

먼저 a = FourCal()처럼 객체를 만들 수 있게 하는 것이다.

```python
class FourCal:
    pass
```

우선 pass 문장만 써있는 FourCal 클래스를 만든다.

### 객체에 숫자 지정할 수 있게 만들기

사칙연산하는 기능을 하는 객체를 만들기 전 a,b로 숫자를 받아 알려주어야한다.

```python
class FourCal:
    def setdata(self, first, second):
        self.first = first
        self.second = second
```

pass 삭제 후 setdata 함수를 만든다. 클래스 안에 구현된 함수는 메서드라고 부른다. 클래스 내부의 함수를 메서드라고 하자.

여기서 self는 특별한 의미를 갖는다. 나중에 setdata()를 사용할 때 a.setdata(4, 2)와 같이 숫자를 넣는데 2개만 넣는다. 그 이유는 a.setdata(4,2)처럼 호출하면 setdata 메서드의 첫번째 매개변수 self에는 setdata메서드를 호출한 객체 a가 자동으로 전달되기 때문.

self.first = a.first 와 같은 의미인데, 문장이 수행되면 a 객체에 객체변수 first가 생성되고 4가 저장된다.

second도 그렇다.

```python
a = FourCal()
b = FourCal()
```

만약 이렇게 a, b 두개의 객체를 생성 후 setdata() 메서드를 통해 숫자를 다르게 지정했다면 숫자는 같을것인가?

a객체의 first와 b객체의 first는 서로 영향을 주지 않고 원래 값을 유지하고 있다. 클래스로 만든 객체의 객체변수는 다른 객체의 객체 변수에 상관 없이 독립적인 값을 유지한다.

### 더하기 기능

```python
class FourCal:
    def setdata(self, first, second):
        self.first = first
        self.second = second
    def add(self)
        result = self.first + self.second
        return result
```

add 메서드를 보면 self를 매개변수로 받고 반환 값은 result이다.

빼기, 곱하기, 나누기 기능은 생략하겠다.

## 생성자(Constructor)

FourCal 클래스의 인스턴스 a에 setdata 메서드를 수행하지 않고 add 메서드를 수행하면 오류가 발행산다. setdata 메서드를 수행해야 객체 a의 변수 first와 second가 생성되기 때문이다.

객체에 초기값을 설정해야 할 때 setdata와 같은 메서드를 호출하여 초기값을 설정하기 보다는 생성자를 구현하는 방법이 안전하다.

파이썬 메서드 이름으로 init를 사용하면 생성자가 된다.

## 클래스의 상속

어떤 클래스를 만들 때 다른 클래스의 기능을 물려받을 수 있게 만들 수 있다.

MoreFourCal 클래스를 만들어 제작해보자.

```python
class MoreFourCal(FourCal):
    pass
```

클래스를 상속하기 위해서는 다음처럼 클래스 이름 뒤 괄호 안에 상속할 클래스 이름을 넣으면 된다.

MoreFourCal 클래스는 FourCal 클래스를 상속했으므로 그의 모든 기능을 사용할 수 있다.

### 상속을 해야하는 이유

보통 상속은 클래스를 변경하지 않고 기능을 추가하거나 기존 기능을 변경할 때 사용한다. 기존 클래스가 라이브러리 형태로 제공되거나 수정이 허용되지 않는 상황이라면 상속을 사용해야한다.

## 메서드 오버라이딩

div() 메서드를 사용해 4, 0을 설정하면 오류가 발생한다. 이때 오류가 아닌 0을 리턴하기 위해선 오버라이딩을 해야한다.

```python
class SafeFourCal(FourCal):
    def div(self):
        if self.second == 0:
            return 0
        else:
            return self.first/self.second
```

SafeFourCal 클래스는 FourCal 클래스의 div 메서드를 동일한 이름으로 다시 작성. 이렇게 부모 클래스에 있는 메서드를 동일한 이름으로 다시 만드는 것을 메서드 오버라이딩 이라고 한다. 메서드를 오버라이딩하면 부모클래스의 메서드 대신 오버라이딩한 메서드가 호출.

## 클래스 변수

```python
class Family:
    lastname = "김"
```

Family 클래스에서 선언한 lastname이 클래스 변수이다.

print(Family.lastname)으로 사용할 수 있다.

```python
a = Family()
b = Family()
```

하지만 이처럼 a, b를 동일한 클래스로 만든 객체를 선언 후 lastname은 똑같이 '김'으로 설정되어있다.

이때 lastname = '박'으로 바꾸면 모든 객체에 영향이 간다. 클래스 변수는 클래스로 만든 모든 객체에 공유된다.

# 2. 모듈

모듈이란 함수나 변수, 클래스를 모아 놓은 파일이다.

## 모듈 만들기

```python
# mod1.py
def add(a,b):
    return a + b
def sub(a,b):
    return a - b
```

위와 같이 mod1을 만들고 디렉터리에 저장.

## 모듈 불러오기

모듈을 불러오기 위해서는 모듈 파일이 저장된 곳에서 python 인터프리터를 실행한다.

```python
import mod1
print(mod1.add(3,4))
```

mod1.py를 불러오기 위해 import 함수를 사용했다. import는 이미 만들어 놓은 파이썬 모듈을 사용할 수 있게 해주는 명령어이다. add함수를 사용하기 위해 mod1.add처럼 모듈 이름 뒤에 .을 붙이고 함수 이름을 쓴다.

모듈 이름을 사용하지 않고 사용하고 싶을때는 

```python
from mod1 import add, sub
# or
from mod1 import *
```

를 사용하면 된다.

## if _ _name__ = "__main__": 의 의미

```python
# mod1.py 
def add(a, b): 
    return a+b

def sub(a, b): 
    return a-b

print(add(1, 4))
print(sub(4, 2))
```

원래 mod1.py에 add, sub의 결과를 출력하는 문장을 추가

[mod1.py](http://mod1.py) 실행 시 결과가 나온다.

그런데 mod1을 improt 할 때는 오류가 생긴다.

이러한 문제를 방지하기 위해 mod1.py파일을 변경해야 한다.

```python
# mod1.py 
def add(a, b): 
    return a+b

def sub(a, b): 
    return a-b

if __name__ == "__main__":
    print(add(1,4))
    print(sub(4,2))
```

이렇게 사용하면 이 파일을 실행했을 때는 참이 되어 if문장이 실행, 대화형 인터프리터나 다른 파일에서 이 모듈을 불러 사용할 때는 거짓이 되어 if문을 진행하지 않는다.

## 클래스나 변수 등을 포함한 모듈

```python
# mod2.py
PI = 3.141592

class Math:
    def solv(self, r):
        return PI * (r**2)

def add(a, b):
    return a + b
```

```python
>>> import mod2
>>> print(mod2.PI)
>>> a = mod2.Math()
>>> print(a.solv(2))
```

이처럼 Math 클래스를 사용할 수 있다.

## 다른 파일에서 모듈 불러오기

C:\doit\modtest.py 파일을 작성한다.

```python
# modtest.py
import mod2
result = mod2.add(3,4)
print(result)
```

다른 파이썬 파일에서도 import 명령어로 다른 모듈을 불러와 사용할 수 있다.

## 모듈을 불러오는 또 다른 방법

먼저 mod2.py파일을 C:\doit\mymod로 이동

1. **sys.path.append 사용하기**

먼저 sys 모듈을 불러온다.

```python
>>> import sys
```

 sys 모듈은 파이썬의 라이브러리 모듈. sys 모듈을 사용하면 파이썬 라이브러리가 설치되어있는 디렉터리를 확인할 수 있다.

```python
>>> sys.path
```

이 명령어로 파이썬 라이브러리가 설치되어있는 디렉터리를 보여준다. 여기에 mymod 폴더를 추가한다.

```python
>>> sys.path.append("C:/doit/mymod")
```

sys.path 명령어로 추가가 된 것을 볼 수 있다.

2. **PYTHONPATH 환경 변수 사용하기**

모듈을 불러오기 위해선 PYTHONPATH 환경 변수를 사용할 수 있다.

```python
C:\doit> set PYTHONPATH = C:\doit\mymod
```

set 명령어를 사용해 PYTHONPATH 환경 변수에 mod2.py파일이 있는 디렉터리 설정.

# 3. 패키지

패키지는 도트(.)를 사용하여 파이썬 모듈을 계층적 구조로 관리할 수 있게 해준다. A, B인 이름의 듈의 경우 A는 패키지 이름이 되고 B는 A의 패키지의 B 모듈이 된다.

```python
game/
    __init__.py
    sound/
        __init__.py
        echo.py
        wav.py
    graphic/
        __init__.py
        screen.py
        render.py
    play/
        __init__.py
        run.py
        test.py
```

가상의 game 패키지의 예

game, sound, graphic, play는 디렉터리 이름, 확장자가 .py인 파일은 파이썬 모듈.

패키지 구조로 만들면 공동 작업이나 유지 보수 등 여러 면에서 유리하다. 그리고 이름이 겹쳐도 안전하게 사용이 가능하다.

## 패키지 만들기

### 패키지 기본 구성 요소 준비

1. 디렉터리 밑에 game 및 서브 디렉터리 생성

```python
C:/doit/game/__init__.py
C:/doit/game/sound/__init__.py
C:/doit/game/sound/echo.py
C:/doit/game/graphic/__init__.py
C:/doit/game/graphic/render.py
```

2. 각 디렉터리에 __init__.py 파일을 만들고 비워둔다.

3. echo.py

```python
# echo.py
def echo_test():
    print("echo")
```

4. render.py

```python
# render.py
def render_test():
    print("render")
```

5. game패키지를 참조할 수 있도록 명령 프롬프트 창에서  set PYTHONPATH 환경 변수에 추가.

> 이 코드는 명령 프롬프트에서 파이썬 인터프리터로 실행해야 한다.

## 패키지 안의 함수 실행하기

패키지를 사용해 echo.py파일의 echo_test 함수를 실행, 방법은 3가지가 있다.

1. import하여 실행

```python
>>> import game.sound.echo
>>> game.sound.echo.echo_test()
```

2. from ... import 하여 실행

```python
>>> from game.sound import echo
>>> echo.echo_test()
```

3. echo 모듈의 echo_test 함수를 직접 import

```python
>>> from game.sound.echo import echo_test
>>> echo_test()
```

하지만 이처럼 함수를 사용할 수 없다.

```python
>>> import game
>>> game.sound.echo.echo_test()
```

import game을 수행하면 game 디렉터리의 모듈 또는 game 디렉터리의 __init__.py에 정의한 것만 참조할 수 있다.

## __init__.py의 용도

__init__.py는 해당 디렉터리가 패키지의 일부임을 알려주는 역할을 한다. 각 패키지에 포함된 디렉터리에 이 파일이 없다면 패키지로 인식되지 않는다.

```python
>>> from game.sound import *
>>> echo.echo_test()
```

이렇게 하면 오류가 뜬다. game.sound 패키지에서 모든것을 import하고 모듈을 사용할 수 없다.

이렇게 디렉터리의 모듈을 *을 사용해서 import하려면 import 할 때에는 해당 디렉터리의 __init__.py 파일에 __all__ 변수를 설정하고 모듈을 정의해줘야 한다.

```python
# C:/doit/game/sound/__init__.py
__all__ = ['echo']
```

여기서 __all__은 sound 디렉터리에서 *기호로 import 할 경우 정의된 echo 모듈만 import 된다는 의미이다.

## relative 패키지

graphic  디렉터리에서 render.py모듈이 sound 디렉터리의  [echo.py](http://echo.py) 모듈을 사용하려면 다음과 같이 수정한다.

```python
# render.py
from game.sound.echo import echo_test

def render_test():
    print("render")
    echo_test()
```

```python
>>> from game.graphic.render import render_test
>>> render_test()
```

잘 수행되는 것을 볼 수 있다.

```python
# render.py
from ..sound.echo import echo_test

def render_test():
    print("render")
    echo_test()
```

이처럼 ..을 사용하여 import 할 수 있다. 위의 예제처럼 전체 경로를 사용하여 import 하는 것이 아닌 relative하게 import하는 것이다. 여기서 .. 는 부모 디렉터리를 의미한다. 

. 은 현재 디렉터리를 의미한다.

# 4. 예외 처리

## 오류 발생 이유

- 없는 파일을 열려고 시도하면 FileNotFoundError가 발생한다.
- 0으로 나누면 ZeroDivisionError  오류가 발생한다.
- a의 리스트는 [1,2,3] 인데 a[4]는 a리스트에서 얻을 수 없는 값이기 때문에 IndexError 오류가 발생한다.

## 오류 예외 처리 기법

### try, except문

```python
try:
    ...
except[발생 오류[as 오류 메시지 변수]]:
    ...
```

try 블록 수행 중 오류 발생하면 except 블록 수행.

except 구문은 3가지 방법으로 사용할 수 있다.

1. try, except 만 사용

```python
try:
    ...
except:
    ...
```

이 경우는 오류 종류에 상관 없이 오류가 발생하면 excpet 블록 수행

2. 발생 오류만 포함한 except 문 사용

```python
try:
    ...
except 발생 오류:
    ...
```

오류가 발생했을 때 except 오류 이름과 일치할 때만 블록을 수행

3. 발생 오류와 오류 메시지 변수까지 포함한 except문

```python
try:
    ...
except 발생 오류 as 오류 메시지 변수:
    ...
```

예를 들면

```python
try:
    4 / 0
except ZeroDivisionError as e:
    print(e)
```

### try .. finally

finally 절은 try문 도중 예외 발생 여부에 상관 없이 항상 수행. 보통 finally문은 사용 리소스를 close할 때 사용

```python
f = open('foo.txt','w')
try:
    #수행
finally:
    f.close()
```

### 여러개의 오류 처리

```python
try:
    ...
except error1:
    ...
except error2:
    ...
```

예를 들면

```python
try:
    a = [1,2]
    print(a[3])
    4/0
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다.")
except IndexError:
    print("인덱싱 할 수 없습니다.")
```

또는 한번에

```python
try:
    a = [1,2]
    print(a[3])
    4/0
except (ZeroDivisionError, IndexError) as e:
    print(e)
```

2개 이상의 오류를 동일하게 처리하기 위해 괄호를 사용하여 묶어 처리한다.

## 오류 회피하기

```python
try:
    f = open("없는파일.txt","w")
except FileNotFoundError:
    pass
```

try문 안에서 에러 발생 시 pass를 사용해 오류 회피

## 오류 발생시키기

```python
class Bird:
    def fly(self):
        raise NotImplementedError
```

Bird 클래스를 상속받는 자식 클래스는 반드시 fly 함수를 구현하기 위해 NotImplementedError를 통해 일부러 오류를 일으킨다.

```python
class Eagle(Bird):
    pass

eagle = Eagle()
eagle.fly()
```

Eagle 클래스는 Bird 클래스를 상속, Eagle 클래스에서 fly 함수를 구현하지 않았기 때문에 Bird클래스의 fly함수 호출, raise함수의 NotImplementedError로 인해 에러 발생

```python
class Eagle(Bird):
    def fly(self):
        print("very fast")

eagle = Eagle()
eagle.fly()
```

이처럼 상속하는 클래스 내에서 메서드 오버라이딩을 통해 구현해야 한다.

## 예외 만들기

특정 예외를 만들어서 사용

```python
class MyError(Exception):
    pass
```

별명 출력 함수 작성

```python
def say_nick(nick):
    if nick == '바보':
        raise MyError()
    print(nick)

say_nick("천사")
say_nick("바보")
```

이러면 천사 출력 후 MyError가 발생.

예외 처리 기법으로 MyError 발생 예외처리를 해보자

```python
try:
    say_nick("천사")
    say_nick("바보")
except MyError:
    print('허용되지 않는 별명')
```

프로그램 실행하면 에러 출력.

오류 메시지를 사용하고 싶으면 except .. as .. 를 사용

```python
try:
    say_nick("천사")
    say_nick("바보")
except MyError as e:
    print(e)
```

프로그램 실행하면 print(e)로 오류 메시지가 출력되지 않는다. 오류 메시지가 보이게 하려면 오류 클래스에 다음과 같은 __str__ 메서드를 구현해야 한다. 이 메서드는 print(e)처럼 오류 메시지를 print문으로 출력할 경우 호출되는 메서드이다.

```python
class MyError(Exception):
    def __str__(self):
        return "허용되지 않는 별명입니다."
```

# 5. 내장 함수