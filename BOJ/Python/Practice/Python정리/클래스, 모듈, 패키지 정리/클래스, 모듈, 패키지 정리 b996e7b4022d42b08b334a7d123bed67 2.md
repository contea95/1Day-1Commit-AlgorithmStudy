# 클래스, 모듈, 패키지 정리

# 1. 클래스

## 클래스 필요 이유

계산기를 생각해보자. 숫자 3을 입력하고 +기호 입력 후 입력한 4를 입력하면 결과값인 7을 출력, 다시 +를 입력후 3을 입력하면 기존 결과값 7에 3을 더한 10을 보여준다. 이는 이전에 계산한 결과값을 항상 메모리 어딘가에 저장하고 있어야 한다.

```python
result = 0

def add(num):
    global result
    result += num
    return result

print(add(3))
print(add(4))
```

이전에 계산한 결과값으 유지하기 위해 result 전역 변수(global)를 사용한다. 프로그램을 실행하면 예상한 대로 3, 7과 같은 결과값이 출력된다.

그런데 만일 한 프로그램에서 2대의 계산기가 필요하면 어떻게 될까? 각 계산기는 각각의 결과값을 유지해야 하기 때문에 위와 같이 add 함수 하나만으로는 결과값을 따로 유지할 수 없다.

이 문제를 해결하려면 add1, add2와 같은 함수를 따로 추가해야 한다. 하지만 이렇게 한다면 계산기가 3개, 4개 등으로 늘어나면 어떻게 해야할까?

이는 클래프를 사용하면 해결할 수 있다.

```python
class Calculator:
    def __init__(self):
		    self.result = 0

    def add(self, num):
        self.result += num
        return self.result

cal1 = Calculator()
cal2 = Calculator()

print(cal1.add(3))
```

Calculator 클래스로 만든 별개의 계산기 cal1, cal2 (객체)가 각각의 역할을 한다. 그리고 계산기(cal1, cal2)의 결과값 역시 다른 계산기의 결과값과 상관없이 독립적인 값을 유지한다. 클래스를 사용하면 계산기 대수가 늘어나더라도 객체를 생성하기만 하면 되기 때문에 함수를 사용하는 경우와 달리 매우 간단해진다. 빼기 기능도 클래스에 추가해주면 된다.

```python
def sub(self, num):
    self.result -=num
    return self.result
```

## 클래스와 객체

클래스를 과자와 틀에 비교해보자

- 과자 틀 → 클래스
- 과자 틀에 의해 만들어진 과자 → 객체

클래스로 만든 객체는 각 객체마다 고유한 성격을 가진다.

### 객체와 인스턴스 차이

클래스로 만든 객체를 인스턴스라고 한다. 객체와 인스턴스의 차이를 알아보자.

a = Cookie()로 만든 a는 객체이다. 그리고 객체 a는 Cookie의 인스턴스이다. 즉 인스턴스는 특정 개체(a)가 어떤 클래스의 객체인지 설명할 때 사용한다. 'a는 인스턴스' 보다는 'a는 객체'라는 표현이 어울리며 'a는 Cookie의 객체' 보다는 'a는 Cookie의 인스턴스'라는 표현으로 얘기해야한다.

## 사칙연산 클래스 만드는 과정

### 클래스 구상하기

클래스 객체 중심으로 어떤 식으로 동작하게 할 것인지 구상 후 하나씩 해결하면서 완성해 나가는 것이 좋다.

```python
a = FourCal() # 사칙 연산을 하는 FourCal클래스
a.setdata(4,2) # 데이터 세트
a.add()
a.mul()
a.sub()
a.div()
```

위 기능을 수행하는 클래스 제작

### 클래스 구조 만들기

먼저 a = FourCal()처럼 객체를 만들 수 있게 하는 것이다.

```python
class FourCal:
    pass
```

우선 pass 문장만 써있는 FourCal 클래스를 만든다.

### 객체에 숫자 지정할 수 있게 만들기

사칙연산하는 기능을 하는 객체를 만들기 전 a,b로 숫자를 받아 알려주어야한다.

```python
class FourCal:
    def setdata(self, first, second):
        self.first = first
        self.second = second
```

pass 삭제 후 setdata 함수를 만든다. 클래스 안에 구현된 함수는 메서드라고 부른다. 클래스 내부의 함수를 메서드라고 하자.

여기서 self는 특별한 의미를 갖는다. 나중에 setdata()를 사용할 때 a.setdata(4, 2)와 같이 숫자를 넣는데 2개만 넣는다. 그 이유는 a.setdata(4,2)처럼 호출하면 setdata 메서드의 첫번째 매개변수 self에는 setdata메서드를 호출한 객체 a가 자동으로 전달되기 때문.

self.first = a.first 와 같은 의미인데, 문장이 수행되면 a 객체에 객체변수 first가 생성되고 4가 저장된다.

second도 그렇다.

```python
a = FourCal()
b = FourCal()
```

만약 이렇게 a, b 두개의 객체를 생성 후 setdata() 메서드를 통해 숫자를 다르게 지정했다면 숫자는 같을것인가?

a객체의 first와 b객체의 first는 서로 영향을 주지 않고 원래 값을 유지하고 있다. 클래스로 만든 객체의 객체변수는 다른 객체의 객체 변수에 상관 없이 독립적인 값을 유지한다.

### 더하기 기능

```python
class FourCal:
    def setdata(self, first, second):
        self.first = first
        self.second = second
    def add(self)
        result = self.first + self.second
        return result
```

add 메서드를 보면 self를 매개변수로 받고 반환 값은 result이다.

빼기, 곱하기, 나누기 기능은 생략하겠다.

## 생성자(Constructor)

FourCal 클래스의 인스턴스 a에 setdata 메서드를 수행하지 않고 add 메서드를 수행하면 오류가 발행산다. setdata 메서드를 수행해야 객체 a의 변수 first와 second가 생성되기 때문이다.

객체에 초기값을 설정해야 할 때 setdata와 같은 메서드를 호출하여 초기값을 설정하기 보다는 생성자를 구현하는 방법이 안전하다.

파이썬 메서드 이름으로 init를 사용하면 생성자가 된다.

## 클래스의 상속

어떤 클래스를 만들 때 다른 클래스의 기능을 물려받을 수 있게 만들 수 있다.

MoreFourCal 클래스를 만들어 제작해보자.

```python
class MoreFourCal(FourCal):
    pass
```

클래스를 상속하기 위해서는 다음처럼 클래스 이름 뒤 괄호 안에 상속할 클래스 이름을 넣으면 된다.

MoreFourCal 클래스는 FourCal 클래스를 상속했으므로 그의 모든 기능을 사용할 수 있다.

### 상속을 해야하는 이유

보통 상속은 클래스를 변경하지 않고 기능을 추가하거나 기존 기능을 변경할 때 사용한다. 기존 클래스가 라이브러리 형태로 제공되거나 수정이 허용되지 않는 상황이라면 상속을 사용해야한다.

## 메서드 오버라이딩

div() 메서드를 사용해 4, 0을 설정하면 오류가 발생한다. 이때 오류가 아닌 0을 리턴하기 위해선 오버라이딩을 해야한다.

```python
class SafeFourCal(FourCal):
    def div(self):
        if self.second == 0:
            return 0
        else:
            return self.first/self.second
```

SafeFourCal 클래스는 FourCal 클래스의 div 메서드를 동일한 이름으로 다시 작성. 이렇게 부모 클래스에 있는 메서드를 동일한 이름으로 다시 만드는 것을 메서드 오버라이딩 이라고 한다. 메서드를 오버라이딩하면 부모클래스의 메서드 대신 오버라이딩한 메서드가 호출.

## 클래스 변수

```python
class Family:
    lastname = "김"
```

Family 클래스에서 선언한 lastname이 클래스 변수이다.

print(Family.lastname)으로 사용할 수 있다.

```python
a = Family()
b = Family()
```

하지만 이처럼 a, b를 동일한 클래스로 만든 객체를 선언 후 lastname은 똑같이 '김'으로 설정되어있다.

이때 lastname = '박'으로 바꾸면 모든 객체에 영향이 간다. 클래스 변수는 클래스로 만든 모든 객체에 공유된다.

# 2. 모듈

모듈이란 함수나 변수, 클래스를 모아 놓은 파일이다.

## 모듈 만들기

```python
# mod1.py
def add(a,b):
    return a + b
def sub(a,b):
    return a - b
```

위와 같이 mod1을 만들고 디렉터리에 저장.

## 모듈 불러오기

모듈을 불러오기 위해서는 모듈 파일이 저장된 곳에서 python 인터프리터를 실행한다.

```python
import mod1
print(mod1.add(3,4))
```

mod1.py를 불러오기 위해 import 함수를 사용했다. import는 이미 만들어 놓은 파이썬 모듈을 사용할 수 있게 해주는 명령어이다. add함수를 사용하기 위해 mod1.add처럼 모듈 이름 뒤에 .을 붙이고 함수 이름을 쓴다.

모듈 이름을 사용하지 않고 사용하고 싶을때는 

```python
from mod1 import add, sub
# or
from mod1 import *
```

를 사용하면 된다.

## if _ _name__ = "__main__": 의 의미

```python
# mod1.py 
def add(a, b): 
    return a+b

def sub(a, b): 
    return a-b

print(add(1, 4))
print(sub(4, 2))
```

원래 mod1.py에 add, sub의 결과를 출력하는 문장을 추가

[mod1.py](http://mod1.py) 실행 시 결과가 나온다.

그런데 mod1을 improt 할 때는 오류가 생긴다.

이러한 문제를 방지하기 위해 mod1.py파일을 변경해야 한다.

```python
# mod1.py 
def add(a, b): 
    return a+b

def sub(a, b): 
    return a-b

if __name__ == "__main__":
    print(add(1,4))
    print(sub(4,2))
```

이렇게 사용하면 이 파일을 실행했을 때는 참이 되어 if문장이 실행, 대화형 인터프리터나 다른 파일에서 이 모듈을 불러 사용할 때는 거짓이 되어 if문을 진행하지 않는다.

## 클래스나 변수 등을 포함한 모듈

```python
# mod2.py
PI = 3.141592

class Math:
    def solv(self, r):
        return PI * (r**2)

def add(a, b):
    return a + b
```

```python
>>> import mod2
>>> print(mod2.PI)
>>> a = mod2.Math()
>>> print(a.solv(2))
```

이처럼 Math 클래스를 사용할 수 있다.

## 다른 파일에서 모듈 불러오기

C:\doit\modtest.py 파일을 작성한다.

```python
# modtest.py
import mod2
result = mod2.add(3,4)
print(result)
```

다른 파이썬 파일에서도 import 명령어로 다른 모듈을 불러와 사용할 수 있다.

## 모듈을 불러오는 또 다른 방법

먼저 mod2.py파일을 C:\doit\mymod로 이동

1. **sys.path.append 사용하기**

먼저 sys 모듈을 불러온다.

```python
>>> import sys
```

 sys 모듈은 파이썬의 라이브러리 모듈. sys 모듈을 사용하면 파이썬 라이브러리가 설치되어있는 디렉터리를 확인할 수 있다.

```python
>>> sys.path
```

이 명령어로 파이썬 라이브러리가 설치되어있는 디렉터리를 보여준다. 여기에 mymod 폴더를 추가한다.

```python
>>> sys.path.append("C:/doit/mymod")
```

sys.path 명령어로 추가가 된 것을 볼 수 있다.

2. **PYTHONPATH 환경 변수 사용하기**

모듈을 불러오기 위해선 PYTHONPATH 환경 변수를 사용할 수 있다.

```python
C:\doit> set PYTHONPATH = C:\doit\mymod
```

set 명령어를 사용해 PYTHONPATH 환경 변수에 mod2.py파일이 있는 디렉터리 설정.